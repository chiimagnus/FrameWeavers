<!-- Generated by SpecStory -->

# 集成所有api路由到app.py (2025-07-25 01:47Z)

_**User**_

帮我在app.py文件中集成所有api路由，供前端开发调用。视频上传与存储请api参考
@video_upload_api.py ，基础帧API请参考
@diversity_frame_extractor.py 集成，关键帧api请参考
@diversity_frame_extractor.py 集成。

---

_**Assistant**_

我将在app.py中集成所有API路由，包括视频上传、基础帧提取和关键帧提取功能。

---

Read file: app.py

---

Read file: requirements.txt

---

<details><summary>Edit file: app.py</summary>

我将创建一个完整的Flask应用程序，集成视频上传API和视频帧提取API。

**Chunk 1**
Lines added: 626, lines removed: 1

```diff
@@ -1,1 +1,626 @@
- 
+ from flask import Flask, request, jsonify, send_from_directory
+ from werkzeug.utils import secure_filename
+ import os
+ import uuid
+ import threading
+ import time
+ import asyncio
+ from datetime import datetime
+ from diversity_frame_extractor import DiversityFrameExtractor
+ 
+ app = Flask(__name__)
+ 
+ # 配置
+ UPLOAD_FOLDER = 'uploads'
+ FRAMES_FOLDER = 'frames'
+ ALLOWED_EXTENSIONS = {'mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', '3gp'}
+ MAX_CONTENT_LENGTH = 800 * 1024 * 1024  # 800MB
+ 
+ app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
+ app.config['FRAMES_FOLDER'] = FRAMES_FOLDER
+ app.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH
+ 
+ # 确保上传和帧目录存在
+ os.makedirs(UPLOAD_FOLDER, exist_ok=True)
+ os.makedirs(FRAMES_FOLDER, exist_ok=True)
+ 
+ # 任务状态存储
+ task_status = {}
+ 
+ def allowed_file(filename):
+     """检查文件扩展名是否允许"""
+     return '.' in filename and \
+            filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
+ 
+ def process_videos_async(task_id, video_files):
+     """异步处理视频的后台任务"""
+     try:
+         task_status[task_id]['status'] = 'processing'
+         task_status[task_id]['message'] = '正在为您织造回忆，请稍候...'
+         
+         # 模拟视频处理过程
+         for i, video_file in enumerate(video_files):
+             # 更新进度
+             progress = int((i + 1) / len(video_files) * 100)
+             task_status[task_id]['progress'] = progress
+             task_status[task_id]['message'] = f'正在处理第 {i+1}/{len(video_files)} 个视频...'
+             
+             # 这里添加实际的视频处理逻辑
+             # 例如：调用视频帧提取、AI分析等
+             time.sleep(2)  # 模拟处理时间
+         
+         # 处理完成
+         task_status[task_id]['status'] = 'completed'
+         task_status[task_id]['message'] = '回忆织造完成！'
+         task_status[task_id]['progress'] = 100
+         
+     except Exception as e:
+         task_status[task_id]['status'] = 'error'
+         task_status[task_id]['message'] = f'处理失败: {str(e)}'
+         task_status[task_id]['error'] = str(e)
+ 
+ # 创建异步事件循环
+ async_loop = asyncio.new_event_loop()
+ 
+ def run_async_task(coro):
+     """在异步事件循环中运行协程"""
+     asyncio.set_event_loop(async_loop)
+     return async_loop.run_until_complete(coro)
+ 
+ def start_async_loop():
+     """启动异步事件循环"""
+     asyncio.set_event_loop(async_loop)
+     async_loop.run_forever()
+ 
+ # 在单独的线程中启动异步事件循环
+ threading.Thread(target=start_async_loop, daemon=True).start()
+ 
+ # ========================= API 路由 =========================
+ 
+ # 1. 视频上传API
+ @app.route('/api/upload/videos', methods=['POST'])
+ def upload_videos():
+     """视频上传接口"""
+     try:
+         # 检查设备唯一码
+         device_id = request.form.get('device_id')
+         if not device_id:
+             return jsonify({
+                 'success': False,
+                 'message': '缺少设备唯一码'
+             }), 400
+         
+         # 检查是否有文件
+         if 'videos' not in request.files:
+             return jsonify({
+                 'success': False,
+                 'message': '未找到视频文件'
+             }), 400
+         
+         files = request.files.getlist('videos')
+         
+         if not files or all(file.filename == '' for file in files):
+             return jsonify({
+                 'success': False,
+                 'message': '未选择任何文件'
+             }), 400
+         
+         # 验证文件
+         valid_files = []
+         invalid_files = []
+         
+         for file in files:
+             if file and allowed_file(file.filename):
+                 valid_files.append(file)
+             else:
+                 invalid_files.append(file.filename if file.filename else '未知文件')
+         
+         if not valid_files:
+             return jsonify({
+                 'success': False,
+                 'message': '没有有效的视频文件',
+                 'invalid_files': invalid_files
+             }), 400
+         
+         # 生成任务ID
+         task_id = str(uuid.uuid4())
+         
+         # 保存文件
+         saved_files = []
+         for file in valid_files:
+             filename = secure_filename(file.filename)
+             # 添加时间戳避免文件名冲突
+             timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
+             filename = f"{timestamp}_{filename}"
+             filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
+             file.save(filepath)
+             saved_files.append({
+                 'original_name': file.filename,
+                 'saved_name': filename,
+                 'filepath': filepath,
+                 'size': os.path.getsize(filepath)
+             })
+         
+         # 初始化任务状态
+         task_status[task_id] = {
+             'status': 'uploaded',
+             'message': '视频上传成功，准备开始处理...',
+             'progress': 0,
+             'files': saved_files,
+             'device_id': device_id,
+             'created_at': datetime.now().isoformat()
+         }
+         
+         # 启动异步处理任务
+         thread = threading.Thread(
+             target=process_videos_async, 
+             args=(task_id, saved_files)
+         )
+         thread.daemon = True
+         thread.start()
+         
+         return jsonify({
+             'success': True,
+             'message': '视频上传成功',
+             'task_id': task_id,
+             'device_id': device_id,
+             'uploaded_files': len(saved_files),
+             'invalid_files': invalid_files if invalid_files else None
+         }), 200
+         
+     except Exception as e:
+         return jsonify({
+             'success': False,
+             'message': f'上传失败: {str(e)}'
+         }), 500
+ 
+ # 2. 获取任务状态API
+ @app.route('/api/task/status/<task_id>', methods=['GET'])
+ def get_task_status(task_id):
+     """获取任务处理状态"""
+     if task_id not in task_status:
+         return jsonify({
+             'success': False,
+             'message': '任务不存在'
+         }), 404
+     
+     return jsonify({
+         'success': True,
+         'task_id': task_id,
+         **task_status[task_id]
+     }), 200
+ 
+ # 3. 取消任务API
+ @app.route('/api/task/cancel/<task_id>', methods=['POST'])
+ def cancel_task(task_id):
+     """取消任务"""
+     if task_id not in task_status:
+         return jsonify({
+             'success': False,
+             'message': '任务不存在'
+         }), 404
+     
+     if task_status[task_id]['status'] in ['completed', 'error']:
+         return jsonify({
+             'success': False,
+             'message': '任务已完成或出错，无法取消'
+         }), 400
+     
+     task_status[task_id]['status'] = 'cancelled'
+     task_status[task_id]['message'] = '任务已取消'
+     
+     return jsonify({
+         'success': True,
+         'message': '任务已取消'
+     }), 200
+ 
+ # 4. 获取设备任务历史API
+ @app.route('/api/device/<device_id>/tasks', methods=['GET'])
+ def get_device_tasks(device_id):
+     """获取设备的所有任务历史"""
+     device_tasks = []
+     
+     for task_id, task_info in task_status.items():
+         if task_info.get('device_id') == device_id:
+             device_tasks.append({
+                 'task_id': task_id,
+                 'status': task_info['status'],
+                 'message': task_info['message'],
+                 'progress': task_info.get('progress', 0),
+                 'created_at': task_info['created_at'],
+                 'file_count': len(task_info.get('files', []))
+             })
+     
+     # 按创建时间倒序排列
+     device_tasks.sort(key=lambda x: x['created_at'], reverse=True)
+     
+     return jsonify({
+         'success': True,
+         'device_id': device_id,
+         'tasks': device_tasks,
+         'total_tasks': len(device_tasks)
+     }), 200
+ 
+ # 5. 基础帧提取API
+ @app.route('/api/extract/base-frames', methods=['POST'])
+ def extract_base_frames():
+     """提取视频基础帧"""
+     try:
+         # 检查是否提供了任务ID
+         task_id = request.form.get('task_id')
+         if not task_id or task_id not in task_status:
+             return jsonify({
+                 'success': False,
+                 'message': '任务ID无效或不存在'
+             }), 400
+             
+         # 检查任务状态
+         if task_status[task_id]['status'] != 'uploaded' and task_status[task_id]['status'] != 'completed':
+             return jsonify({
+                 'success': False,
+                 'message': f'任务状态不允许提取帧: {task_status[task_id]["status"]}'
+             }), 400
+             
+         # 获取视频文件
+         video_files = task_status[task_id].get('files', [])
+         if not video_files:
+             return jsonify({
+                 'success': False,
+                 'message': '任务中没有可用的视频文件'
+             }), 400
+             
+         # 获取参数
+         target_interval = float(request.form.get('interval', 1.0))  # 默认1秒
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'extracting_base_frames'
+         task_status[task_id]['message'] = '正在提取基础帧...'
+         task_status[task_id]['progress'] = 0
+         
+         # 为每个视频创建单独的输出目录
+         results = []
+         
+         for i, video_file in enumerate(video_files):
+             # 更新进度
+             progress = int((i / len(video_files)) * 100)
+             task_status[task_id]['progress'] = progress
+             
+             # 创建视频专属的输出目录
+             video_name = os.path.splitext(os.path.basename(video_file['filepath']))[0]
+             output_dir = os.path.join(app.config['FRAMES_FOLDER'], f"{task_id}_{video_name}")
+             os.makedirs(output_dir, exist_ok=True)
+             
+             # 创建抽帧器
+             extractor = DiversityFrameExtractor(output_dir=output_dir)
+             
+             # 提取基础帧
+             base_frames = extractor.extract_uniform_frames(
+                 video_path=video_file['filepath'],
+                 target_interval_seconds=target_interval
+             )
+             
+             # 记录结果
+             results.append({
+                 'video_name': video_file['original_name'],
+                 'base_frames_count': len(base_frames),
+                 'base_frames_paths': base_frames,
+                 'output_dir': output_dir
+             })
+             
+             # 更新任务状态
+             task_status[task_id]['message'] = f'已处理 {i+1}/{len(video_files)} 个视频'
+             task_status[task_id]['progress'] = int(((i+1) / len(video_files)) * 100)
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'base_frames_extracted'
+         task_status[task_id]['message'] = '基础帧提取完成'
+         task_status[task_id]['progress'] = 100
+         task_status[task_id]['base_frames_results'] = results
+         
+         return jsonify({
+             'success': True,
+             'message': '基础帧提取成功',
+             'task_id': task_id,
+             'results': results
+         }), 200
+         
+     except Exception as e:
+         if task_id in task_status:
+             task_status[task_id]['status'] = 'error'
+             task_status[task_id]['message'] = f'基础帧提取失败: {str(e)}'
+             task_status[task_id]['error'] = str(e)
+             
+         return jsonify({
+             'success': False,
+             'message': f'基础帧提取失败: {str(e)}'
+         }), 500
+ 
+ # 6. 关键帧提取API
+ @app.route('/api/extract/key-frames', methods=['POST'])
+ def extract_key_frames():
+     """提取视频关键帧"""
+     try:
+         # 检查是否提供了任务ID
+         task_id = request.form.get('task_id')
+         if not task_id or task_id not in task_status:
+             return jsonify({
+                 'success': False,
+                 'message': '任务ID无效或不存在'
+             }), 400
+             
+         # 检查任务状态
+         if task_status[task_id]['status'] != 'base_frames_extracted' and task_status[task_id]['status'] != 'completed':
+             return jsonify({
+                 'success': False,
+                 'message': f'任务状态不允许提取关键帧: {task_status[task_id]["status"]}'
+             }), 400
+             
+         # 获取参数
+         target_key_frames = int(request.form.get('target_frames', 8))  # 默认8个关键帧
+         significance_weight = float(request.form.get('significance_weight', 0.6))  # 默认0.6
+         quality_weight = float(request.form.get('quality_weight', 0.4))  # 默认0.4
+         max_concurrent = int(request.form.get('max_concurrent', 50))  # 默认最大并发50
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'extracting_key_frames'
+         task_status[task_id]['message'] = '正在提取关键帧...'
+         task_status[task_id]['progress'] = 0
+         
+         # 获取基础帧结果
+         base_frames_results = task_status[task_id].get('base_frames_results', [])
+         if not base_frames_results:
+             return jsonify({
+                 'success': False,
+                 'message': '没有找到基础帧提取结果'
+             }), 400
+             
+         # 处理每个视频的关键帧
+         key_frames_results = []
+         
+         for i, result in enumerate(base_frames_results):
+             # 更新进度
+             progress = int((i / len(base_frames_results)) * 100)
+             task_status[task_id]['progress'] = progress
+             task_status[task_id]['message'] = f'正在处理第 {i+1}/{len(base_frames_results)} 个视频的关键帧...'
+             
+             # 获取输出目录和视频名称
+             output_dir = result['output_dir']
+             video_name = result['video_name']
+             
+             # 创建抽帧器
+             extractor = DiversityFrameExtractor(output_dir=output_dir)
+             
+             # 获取基础帧路径
+             base_frames = result['base_frames_paths']
+             
+             # 分析基础帧并提取关键帧
+             analyzed_frames = run_async_task(
+                 extractor.analyze_frames_with_ai_async(
+                     frame_paths=base_frames,
+                     max_concurrent=max_concurrent
+                 )
+             )
+             
+             # 筛选关键帧
+             selected_frames = extractor.select_key_frames_by_ai(
+                 analyzed_frames=analyzed_frames,
+                 target_key_frames=target_key_frames,
+                 significance_weight=significance_weight,
+                 quality_weight=quality_weight
+             )
+             
+             # 保存关键帧
+             key_frame_paths = extractor.save_key_frames(
+                 selected_frames=selected_frames,
+                 output_prefix=f"key_{video_name}"
+             )
+             
+             # 保存关键帧信息到JSON
+             json_file_path = extractor.save_keyframes_to_json(
+                 selected_frames=selected_frames,
+                 video_path=video_name
+             )
+             
+             # 记录结果
+             key_frames_results.append({
+                 'video_name': video_name,
+                 'base_frames_count': len(base_frames),
+                 'key_frames_count': len(selected_frames),
+                 'key_frames_paths': key_frame_paths,
+                 'json_file_path': json_file_path,
+                 'output_dir': output_dir
+             })
+             
+             # 更新任务状态
+             task_status[task_id]['progress'] = int(((i+1) / len(base_frames_results)) * 100)
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'completed'
+         task_status[task_id]['message'] = '关键帧提取完成'
+         task_status[task_id]['progress'] = 100
+         task_status[task_id]['key_frames_results'] = key_frames_results
+         
+         return jsonify({
+             'success': True,
+             'message': '关键帧提取成功',
+             'task_id': task_id,
+             'results': key_frames_results
+         }), 200
+         
+     except Exception as e:
+         if task_id in task_status:
+             task_status[task_id]['status'] = 'error'
+             task_status[task_id]['message'] = f'关键帧提取失败: {str(e)}'
+             task_status[task_id]['error'] = str(e)
+             
+         return jsonify({
+             'success': False,
+             'message': f'关键帧提取失败: {str(e)}'
+         }), 500
+ 
+ # 7. 统一智能处理API
+ @app.route('/api/process/unified', methods=['POST'])
+ def unified_smart_process():
+     """统一智能处理API - 一键完成所有处理"""
+     try:
+         # 检查是否提供了任务ID
+         task_id = request.form.get('task_id')
+         if not task_id or task_id not in task_status:
+             return jsonify({
+                 'success': False,
+                 'message': '任务ID无效或不存在'
+             }), 400
+             
+         # 检查任务状态
+         if task_status[task_id]['status'] != 'uploaded' and task_status[task_id]['status'] != 'completed':
+             return jsonify({
+                 'success': False,
+                 'message': f'任务状态不允许进行统一处理: {task_status[task_id]["status"]}'
+             }), 400
+             
+         # 获取视频文件
+         video_files = task_status[task_id].get('files', [])
+         if not video_files:
+             return jsonify({
+                 'success': False,
+                 'message': '任务中没有可用的视频文件'
+             }), 400
+             
+         # 获取参数
+         target_key_frames = int(request.form.get('target_frames', 8))  # 默认8个关键帧
+         base_frame_interval = float(request.form.get('interval', 1.0))  # 默认1秒
+         significance_weight = float(request.form.get('significance_weight', 0.6))  # 默认0.6
+         quality_weight = float(request.form.get('quality_weight', 0.4))  # 默认0.4
+         max_concurrent = int(request.form.get('max_concurrent', 50))  # 默认最大并发50
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'unified_processing'
+         task_status[task_id]['message'] = '正在进行统一智能处理...'
+         task_status[task_id]['progress'] = 0
+         
+         # 处理每个视频
+         unified_results = []
+         
+         for i, video_file in enumerate(video_files):
+             # 更新进度
+             progress = int((i / len(video_files)) * 100)
+             task_status[task_id]['progress'] = progress
+             task_status[task_id]['message'] = f'正在处理第 {i+1}/{len(video_files)} 个视频...'
+             
+             # 创建视频专属的输出目录
+             video_name = os.path.splitext(os.path.basename(video_file['filepath']))[0]
+             output_dir = os.path.join(app.config['FRAMES_FOLDER'], f"{task_id}_{video_name}")
+             os.makedirs(output_dir, exist_ok=True)
+             
+             # 创建抽帧器
+             extractor = DiversityFrameExtractor(output_dir=output_dir)
+             
+             # 执行统一智能处理
+             result = run_async_task(
+                 extractor.unified_smart_extraction_async(
+                     video_path=video_file['filepath'],
+                     target_key_frames=target_key_frames,
+                     base_frame_interval=base_frame_interval,
+                     significance_weight=significance_weight,
+                     quality_weight=quality_weight,
+                     max_concurrent=max_concurrent
+                 )
+             )
+             
+             # 记录结果
+             if result['success']:
+                 unified_results.append({
+                     'video_name': video_file['original_name'],
+                     'base_frames_count': len(result['base_frames']),
+                     'key_frames_count': len(result['selected_frames']),
+                     'key_frame_paths': result['key_frame_paths'],
+                     'json_file_path': result['json_file_path'],
+                     'output_dir': output_dir,
+                     'processing_stats': result['processing_stats']
+                 })
+             else:
+                 unified_results.append({
+                     'video_name': video_file['original_name'],
+                     'success': False,
+                     'error': result['error']
+                 })
+             
+             # 更新任务状态
+             task_status[task_id]['message'] = f'已处理 {i+1}/{len(video_files)} 个视频'
+             task_status[task_id]['progress'] = int(((i+1) / len(video_files)) * 100)
+         
+         # 更新任务状态
+         task_status[task_id]['status'] = 'completed'
+         task_status[task_id]['message'] = '统一智能处理完成'
+         task_status[task_id]['progress'] = 100
+         task_status[task_id]['unified_results'] = unified_results
+         
+         return jsonify({
+             'success': True,
+             'message': '统一智能处理成功',
+             'task_id': task_id,
+             'results': unified_results
+         }), 200
+         
+     except Exception as e:
+         if task_id in task_status:
+             task_status[task_id]['status'] = 'error'
+             task_status[task_id]['message'] = f'统一智能处理失败: {str(e)}'
+             task_status[task_id]['error'] = str(e)
+             
+         return jsonify({
+             'success': False,
+             'message': f'统一智能处理失败: {str(e)}'
+         }), 500
+ 
+ # 8. 获取帧图像API
+ @app.route('/api/frames/<task_id>/<path:filename>', methods=['GET'])
+ def get_frame_image(task_id, filename):
+     """获取帧图像"""
+     # 构建可能的路径
+     possible_paths = []
+     
+     # 如果任务存在，尝试查找其所有视频的输出目录
+     if task_id in task_status:
+         # 检查基础帧结果
+         base_frames_results = task_status[task_id].get('base_frames_results', [])
+         for result in base_frames_results:
+             possible_paths.append(result['output_dir'])
+             
+         # 检查关键帧结果
+         key_frames_results = task_status[task_id].get('key_frames_results', [])
+         for result in key_frames_results:
+             possible_paths.append(result['output_dir'])
+             
+         # 检查统一处理结果
+         unified_results = task_status[task_id].get('unified_results', [])
+         for result in unified_results:
+             if isinstance(result, dict) and 'output_dir' in result:
+                 possible_paths.append(result['output_dir'])
+     
+     # 添加默认帧目录
+     possible_paths.append(app.config['FRAMES_FOLDER'])
+     
+     # 尝试在所有可能的路径中查找文件
+     for path in possible_paths:
+         if os.path.exists(os.path.join(path, filename)):
+             return send_from_directory(path, filename)
+     
+     # 如果找不到文件，返回404
+     return jsonify({
+         'success': False,
+         'message': '找不到请求的帧图像'
+     }), 404
+ 
+ # 9. 文件过大错误处理
+ @app.errorhandler(413)
+ def too_large(e):
+     """文件过大错误处理"""
+     return jsonify({
+         'success': False,
+         'message': '文件过大，请选择小于800MB的视频文件'
+     }), 413
+ 
+ if __name__ == '__main__':
+     app.run(debug=True, host='0.0.0.0', port=5000)
+ 
```

</details>

---

# API接口集成完成

我已经在app.py中集成了所有API路由，包括视频上传、基础帧提取和关键帧提取功能。这些API可以供前端开发调用。

## 主要功能模块

1. **视频上传模块**
   - 支持多视频上传
   - 文件格式验证
   - 大小限制（800MB）
   - 基于任务ID的异步处理

2. **基础帧提取模块**
   - 从已上传视频中提取基础帧
   - 可配置提取间隔
   - 自动保存到指定目录

3. **关键帧提取模块**
   - 基于AI分析从基础帧中筛选关键帧
   - 可配置重要性和质量权重
   - 支持异步并发处理

4. **统一智能处理模块**
   - 一键完成从视频到关键帧的全流程处理
   - 高度可配置的参数设置
   - 异步处理提高效率

## API接口列表

1. **视频上传**
   - 路径: `/api/upload/videos`
   - 方法: POST
   - 参数: device_id, videos(文件)

2. **任务状态查询**
   - 路径: `/api/task/status/<task_id>`
   - 方法: GET

3. **取消任务**
   - 路径: `/api/task/cancel/<task_id>`
   - 方法: POST

4. **设备任务历史**
   - 路径: `/api/device/<device_id>/tasks`
   - 方法: GET

5. **基础帧提取**
   - 路径: `/api/extract/base-frames`
   - 方法: POST
   - 参数: task_id, interval(可选)

6. **关键帧提取**
   - 路径: `/api/extract/key-frames`
   - 方法: POST
   - 参数: task_id, target_frames(可选), significance_weight(可选), quality_weight(可选), max_concurrent(可选)

7. **统一智能处理**
   - 路径: `/api/process/unified`
   - 方法: POST
   - 参数: task_id, target_frames(可选), interval(可选), significance_weight(可选), quality_weight(可选), max_concurrent(可选)

8. **获取帧图像**
   - 路径: `/api/frames/<task_id>/<filename>`
   - 方法: GET

## 技术实现要点

1. **异步处理机制**
   - 使用threading处理常规异步任务
   - 使用asyncio处理AI分析的高并发任务
   - 维护全局事件循环以支持异步操作

2. **任务状态管理**
   - 基于字典的任务状态跟踪
   - 实时更新处理进度
   - 完整的错误处理机制

3. **文件组织结构**
   - 按任务ID和视频名称组织输出目录
   - 清晰的文件命名规则
   - JSON格式保存关键帧分析结果

## 使用说明

1. 首先上传视频获取task_id
2. 使用task_id调用基础帧提取API或直接调用统一智能处理API
3. 通过任务状态API监控处理进度
4. 处理完成后，使用帧图像API获取生成的图像

这个集成方案提供了完整的视频处理流程，既支持一键式处理，也支持分步骤处理，满足不同场景的需求。

---

_**User**_

撰写前端请求api文档

---

_**Assistant**_

# 帧织者API文档

## 概述

本文档详细说明了帧织者系统的API接口，供前端开发人员调用。系统提供视频上传、基础帧提取、关键帧提取等功能，支持异步处理和状态查询。

## 基础信息

- **基础URL**: `http://服务器地址:5000`
- **响应格式**: 所有API返回JSON格式数据
- **状态码**:
  - 200: 请求成功
  - 400: 请求参数错误
  - 404: 资源不存在
  - 413: 上传文件过大
  - 500: 服务器内部错误

## API接口列表

### 1. 视频上传

上传一个或多个视频文件，开始处理流程。

- **URL**: `/api/upload/videos`
- **方法**: `POST`
- **Content-Type**: `multipart/form-data`

**请求参数**:

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| device_id | string | 是 | 设备唯一标识码 |
| videos | file[] | 是 | 要上传的视频文件，支持多文件 |

**响应示例**:

```json
{
  "success": true,
  "message": "视频上传成功",
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "device_id": "device_123456",
  "uploaded_files": 2,
  "invalid_files": null
}
```

### 2. 获取任务状态

查询指定任务的处理状态和进度。

- **URL**: `/api/task/status/<task_id>`
- **方法**: `GET`

**路径参数**:

| 参数名 | 类型 | 描述 |
|--------|------|------|
| task_id | string | 任务ID |

**响应示例**:

```json
{
  "success": true,
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "processing",
  "message": "正在处理第 1/2 个视频...",
  "progress": 50,
  "device_id": "device_123456",
  "created_at": "2023-10-15T14:30:15.123456"
}
```

**可能的任务状态**:

- `uploaded`: 视频已上传，等待处理
- `processing`: 正在处理中
- `extracting_base_frames`: 正在提取基础帧
- `base_frames_extracted`: 基础帧提取完成
- `extracting_key_frames`: 正在提取关键帧
- `unified_processing`: 正在进行统一智能处理
- `completed`: 处理完成
- `error`: 处理出错
- `cancelled`: 任务已取消

### 3. 取消任务

取消正在进行的任务。

- **URL**: `/api/task/cancel/<task_id>`
- **方法**: `POST`

**路径参数**:

| 参数名 | 类型 | 描述 |
|--------|------|------|
| task_id | string | 任务ID |

**响应示例**:

```json
{
  "success": true,
  "message": "任务已取消"
}
```

### 4. 获取设备任务历史

获取指定设备的所有任务历史记录。

- **URL**: `/api/device/<device_id>/tasks`
- **方法**: `GET`

**路径参数**:

| 参数名 | 类型 | 描述 |
|--------|------|------|
| device_id | string | 设备唯一标识码 |

**响应示例**:

```json
{
  "success": true,
  "device_id": "device_123456",
  "tasks": [
    {
      "task_id": "550e8400-e29b-41d4-a716-446655440000",
      "status": "completed",
      "message": "处理完成",
      "progress": 100,
      "created_at": "2023-10-15T14:30:15.123456",
      "file_count": 2
    },
    {
      "task_id": "550e8400-e29b-41d4-a716-446655440001",
      "status": "error",
      "message": "处理失败: 文件格式不支持",
      "progress": 30,
      "created_at": "2023-10-14T10:20:15.123456",
      "file_count": 1
    }
  ],
  "total_tasks": 2
}
```

### 5. 基础帧提取

从已上传的视频中提取基础帧。

- **URL**: `/api/extract/base-frames`
- **方法**: `POST`
- **Content-Type**: `application/x-www-form-urlencoded`

**请求参数**:

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| task_id | string | 是 | 任务ID |
| interval | float | 否 | 抽帧时间间隔（秒），默认1.0秒 |

**响应示例**:

```json
{
  "success": true,
  "message": "基础帧提取成功",
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "results": [
    {
      "video_name": "我的视频.mp4",
      "base_frames_count": 30,
      "base_frames_paths": [
        "/path/to/frame1.jpg",
        "/path/to/frame2.jpg",
        "..."
      ],
      "output_dir": "/path/to/frames/directory"
    }
  ]
}
```

### 6. 关键帧提取

从基础帧中提取关键帧。

- **URL**: `/api/extract/key-frames`
- **方法**: `POST`
- **Content-Type**: `application/x-www-form-urlencoded`

**请求参数**:

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| task_id | string | 是 | 任务ID |
| target_frames | int | 否 | 目标关键帧数量，默认8个 |
| significance_weight | float | 否 | 重要性权重(0-1)，默认0.6 |
| quality_weight | float | 否 | 质量权重(0-1)，默认0.4 |
| max_concurrent | int | 否 | 最大并发数，默认50 |

**响应示例**:

```json
{
  "success": true,
  "message": "关键帧提取成功",
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "results": [
    {
      "video_name": "我的视频.mp4",
      "base_frames_count": 30,
      "key_frames_count": 8,
      "key_frames_paths": [
        "/path/to/key_frame1.jpg",
        "/path/to/key_frame2.jpg",
        "..."
      ],
      "json_file_path": "/path/to/keyframes_info.json",
      "output_dir": "/path/to/frames/directory"
    }
  ]
}
```

### 7. 统一智能处理

一键完成从视频到关键帧的全流程处理。

- **URL**: `/api/process/unified`
- **方法**: `POST`
- **Content-Type**: `application/x-www-form-urlencoded`

**请求参数**:

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| task_id | string | 是 | 任务ID |
| target_frames | int | 否 | 目标关键帧数量，默认8个 |
| interval | float | 否 | 基础帧抽取间隔（秒），默认1.0秒 |
| significance_weight | float | 否 | 重要性权重(0-1)，默认0.6 |
| quality_weight | float | 否 | 质量权重(0-1)，默认0.4 |
| max_concurrent | int | 否 | 最大并发数，默认50 |

**响应示例**:

```json
{
  "success": true,
  "message": "统一智能处理成功",
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "results": [
    {
      "video_name": "我的视频.mp4",
      "base_frames_count": 30,
      "key_frames_count": 8,
      "key_frame_paths": [
        "/path/to/unified_key_00.jpg",
        "/path/to/unified_key_01.jpg",
        "..."
      ],
      "json_file_path": "/path/to/keyframes_info.json",
      "output_dir": "/path/to/frames/directory",
      "processing_stats": {
        "total_processing_time": 45.2,
        "base_frames_count": 30,
        "key_frames_count": 8,
        "average_significance_score": 0.75,
        "average_quality_score": 0.82,
        "processing_speed": 0.66
      }
    }
  ]
}
```

### 8. 获取帧图像

获取指定任务的帧图像。

- **URL**: `/api/frames/<task_id>/<filename>`
- **方法**: `GET`

**路径参数**:

| 参数名 | 类型 | 描述 |
|--------|------|------|
| task_id | string | 任务ID |
| filename | string | 图像文件名 |

**响应**:
成功时返回图像文件，失败时返回JSON错误信息。

## 典型使用流程

1. **上传视频**：调用视频上传API，获取`task_id`
2. **监控处理进度**：定期调用任务状态API，检查处理进度
3. **选择处理方式**：
   - 基础处理：调用基础帧提取API，然后调用关键帧提取API
   - 一键处理：直接调用统一智能处理API
4. **获取处理结果**：处理完成后，使用帧图像API获取生成的图像

## 错误处理

所有API在发生错误时会返回带有`success: false`和`message`字段的JSON响应，其中`message`包含错误详情。常见错误包括：

- 参数缺失或无效
- 文件格式不支持
- 文件大小超限（上限800MB）
- 任务不存在或状态不允许操作
- 服务器内部错误

## 注意事项

1. 视频处理为异步操作，需要通过任务状态API监控进度
2. 关键帧提取依赖于基础帧提取的结果
3. 统一智能处理API提供一站式服务，适合大多数场景
4. 处理大视频文件时，请耐心等待，并关注任务状态

---

_**User**_

请输出到api.md文档中

---

_**Assistant**_

<details><summary>Edit file: api.md</summary>

创建一个新的api.md文件，包含帧织者API文档的完整内容

**Chunk 1**
Lines added: 321, lines removed: 1

```diff
@@ -1,1 +1,321 @@
- 
+ # 帧织者API文档
+ 
+ ## 概述
+ 
+ 本文档详细说明了帧织者系统的API接口，供前端开发人员调用。系统提供视频上传、基础帧提取、关键帧提取等功能，支持异步处理和状态查询。
+ 
+ ## 基础信息
+ 
+ - **基础URL**: `http://服务器地址:5000`
+ - **响应格式**: 所有API返回JSON格式数据
+ - **状态码**:
+   - 200: 请求成功
+   - 400: 请求参数错误
+   - 404: 资源不存在
+   - 413: 上传文件过大
+   - 500: 服务器内部错误
+ 
+ ## API接口列表
+ 
+ ### 1. 视频上传
+ 
+ 上传一个或多个视频文件，开始处理流程。
+ 
+ - **URL**: `/api/upload/videos`
+ - **方法**: `POST`
+ - **Content-Type**: `multipart/form-data`
+ 
+ **请求参数**:
+ 
+ | 参数名 | 类型 | 必填 | 描述 |
+ |--------|------|------|------|
+ | device_id | string | 是 | 设备唯一标识码 |
+ | videos | file[] | 是 | 要上传的视频文件，支持多文件 |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "message": "视频上传成功",
+   "task_id": "550e8400-e29b-41d4-a716-446655440000",
+   "device_id": "device_123456",
+   "uploaded_files": 2,
+   "invalid_files": null
+ }
+ ```
+ 
+ ### 2. 获取任务状态
+ 
+ 查询指定任务的处理状态和进度。
+ 
+ - **URL**: `/api/task/status/<task_id>`
+ - **方法**: `GET`
+ 
+ **路径参数**:
+ 
+ | 参数名 | 类型 | 描述 |
+ |--------|------|------|
+ | task_id | string | 任务ID |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "task_id": "550e8400-e29b-41d4-a716-446655440000",
+   "status": "processing",
+   "message": "正在处理第 1/2 个视频...",
+   "progress": 50,
+   "device_id": "device_123456",
+   "created_at": "2023-10-15T14:30:15.123456"
+ }
+ ```
+ 
+ **可能的任务状态**:
+ 
+ - `uploaded`: 视频已上传，等待处理
+ - `processing`: 正在处理中
+ - `extracting_base_frames`: 正在提取基础帧
+ - `base_frames_extracted`: 基础帧提取完成
+ - `extracting_key_frames`: 正在提取关键帧
+ - `unified_processing`: 正在进行统一智能处理
+ - `completed`: 处理完成
+ - `error`: 处理出错
+ - `cancelled`: 任务已取消
+ 
+ ### 3. 取消任务
+ 
+ 取消正在进行的任务。
+ 
+ - **URL**: `/api/task/cancel/<task_id>`
+ - **方法**: `POST`
+ 
+ **路径参数**:
+ 
+ | 参数名 | 类型 | 描述 |
+ |--------|------|------|
+ | task_id | string | 任务ID |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "message": "任务已取消"
+ }
+ ```
+ 
+ ### 4. 获取设备任务历史
+ 
+ 获取指定设备的所有任务历史记录。
+ 
+ - **URL**: `/api/device/<device_id>/tasks`
+ - **方法**: `GET`
+ 
+ **路径参数**:
+ 
+ | 参数名 | 类型 | 描述 |
+ |--------|------|------|
+ | device_id | string | 设备唯一标识码 |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "device_id": "device_123456",
+   "tasks": [
+     {
+       "task_id": "550e8400-e29b-41d4-a716-446655440000",
+       "status": "completed",
+       "message": "处理完成",
+       "progress": 100,
+       "created_at": "2023-10-15T14:30:15.123456",
+       "file_count": 2
+     },
+     {
+       "task_id": "550e8400-e29b-41d4-a716-446655440001",
+       "status": "error",
+       "message": "处理失败: 文件格式不支持",
+       "progress": 30,
+       "created_at": "2023-10-14T10:20:15.123456",
+       "file_count": 1
+     }
+   ],
+   "total_tasks": 2
+ }
+ ```
+ 
+ ### 5. 基础帧提取
+ 
+ 从已上传的视频中提取基础帧。
+ 
+ - **URL**: `/api/extract/base-frames`
+ - **方法**: `POST`
+ - **Content-Type**: `application/x-www-form-urlencoded`
+ 
+ **请求参数**:
+ 
+ | 参数名 | 类型 | 必填 | 描述 |
+ |--------|------|------|------|
+ | task_id | string | 是 | 任务ID |
+ | interval | float | 否 | 抽帧时间间隔（秒），默认1.0秒 |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "message": "基础帧提取成功",
+   "task_id": "550e8400-e29b-41d4-a716-446655440000",
+   "results": [
+     {
+       "video_name": "我的视频.mp4",
+       "base_frames_count": 30,
+       "base_frames_paths": [
+         "/path/to/frame1.jpg",
+         "/path/to/frame2.jpg",
+         "..."
+       ],
+       "output_dir": "/path/to/frames/directory"
+     }
+   ]
+ }
+ ```
+ 
+ ### 6. 关键帧提取
+ 
+ 从基础帧中提取关键帧。
+ 
+ - **URL**: `/api/extract/key-frames`
+ - **方法**: `POST`
+ - **Content-Type**: `application/x-www-form-urlencoded`
+ 
+ **请求参数**:
+ 
+ | 参数名 | 类型 | 必填 | 描述 |
+ |--------|------|------|------|
+ | task_id | string | 是 | 任务ID |
+ | target_frames | int | 否 | 目标关键帧数量，默认8个 |
+ | significance_weight | float | 否 | 重要性权重(0-1)，默认0.6 |
+ | quality_weight | float | 否 | 质量权重(0-1)，默认0.4 |
+ | max_concurrent | int | 否 | 最大并发数，默认50 |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "message": "关键帧提取成功",
+   "task_id": "550e8400-e29b-41d4-a716-446655440000",
+   "results": [
+     {
+       "video_name": "我的视频.mp4",
+       "base_frames_count": 30,
+       "key_frames_count": 8,
+       "key_frames_paths": [
+         "/path/to/key_frame1.jpg",
+         "/path/to/key_frame2.jpg",
+         "..."
+       ],
+       "json_file_path": "/path/to/keyframes_info.json",
+       "output_dir": "/path/to/frames/directory"
+     }
+   ]
+ }
+ ```
+ 
+ ### 7. 统一智能处理
+ 
+ 一键完成从视频到关键帧的全流程处理。
+ 
+ - **URL**: `/api/process/unified`
+ - **方法**: `POST`
+ - **Content-Type**: `application/x-www-form-urlencoded`
+ 
+ **请求参数**:
+ 
+ | 参数名 | 类型 | 必填 | 描述 |
+ |--------|------|------|------|
+ | task_id | string | 是 | 任务ID |
+ | target_frames | int | 否 | 目标关键帧数量，默认8个 |
+ | interval | float | 否 | 基础帧抽取间隔（秒），默认1.0秒 |
+ | significance_weight | float | 否 | 重要性权重(0-1)，默认0.6 |
+ | quality_weight | float | 否 | 质量权重(0-1)，默认0.4 |
+ | max_concurrent | int | 否 | 最大并发数，默认50 |
+ 
+ **响应示例**:
+ 
+ ```json
+ {
+   "success": true,
+   "message": "统一智能处理成功",
+   "task_id": "550e8400-e29b-41d4-a716-446655440000",
+   "results": [
+     {
+       "video_name": "我的视频.mp4",
+       "base_frames_count": 30,
+       "key_frames_count": 8,
+       "key_frame_paths": [
+         "/path/to/unified_key_00.jpg",
+         "/path/to/unified_key_01.jpg",
+         "..."
+       ],
+       "json_file_path": "/path/to/keyframes_info.json",
+       "output_dir": "/path/to/frames/directory",
+       "processing_stats": {
+         "total_processing_time": 45.2,
+         "base_frames_count": 30,
+         "key_frames_count": 8,
+         "average_significance_score": 0.75,
+         "average_quality_score": 0.82,
+         "processing_speed": 0.66
+       }
+     }
+   ]
+ }
+ ```
+ 
+ ### 8. 获取帧图像
+ 
+ 获取指定任务的帧图像。
+ 
+ - **URL**: `/api/frames/<task_id>/<filename>`
+ - **方法**: `GET`
+ 
+ **路径参数**:
+ 
+ | 参数名 | 类型 | 描述 |
+ |--------|------|------|
+ | task_id | string | 任务ID |
+ | filename | string | 图像文件名 |
+ 
+ **响应**:
+ 成功时返回图像文件，失败时返回JSON错误信息。
+ 
+ ## 典型使用流程
+ 
+ 1. **上传视频**：调用视频上传API，获取`task_id`
+ 2. **监控处理进度**：定期调用任务状态API，检查处理进度
+ 3. **选择处理方式**：
+    - 基础处理：调用基础帧提取API，然后调用关键帧提取API
+    - 一键处理：直接调用统一智能处理API
+ 4. **获取处理结果**：处理完成后，使用帧图像API获取生成的图像
+ 
+ ## 错误处理
+ 
+ 所有API在发生错误时会返回带有`success: false`和`message`字段的JSON响应，其中`message`包含错误详情。常见错误包括：
+ 
+ - 参数缺失或无效
+ - 文件格式不支持
+ - 文件大小超限（上限800MB）
+ - 任务不存在或状态不允许操作
+ - 服务器内部错误
+ 
+ ## 注意事项
+ 
+ 1. 视频处理为异步操作，需要通过任务状态API监控进度
+ 2. 关键帧提取依赖于基础帧提取的结果
+ 3. 统一智能处理API提供一站式服务，适合大多数场景
+ 4. 处理大视频文件时，请耐心等待，并关注任务状态 
```

</details>

---

已将API文档输出到api.md文件中，包含了所有接口的详细说明、请求参数、响应示例以及使用流程。

---

